{"pages":[{"title":"About Me","text":"","link":"/about/index.html"}],"posts":[{"title":"GitHub/Gitee Pages + Hexo","text":"使用GitHub/Gitee Pages + hexo搭建个人文档记录 Requirements Node.js Git Install Hexo:12345$ npm install -g hexo-cli$ npm ls -g --depth=0/usr/local/lib├── hexo-cli@1.1.0└── npm@6.4.1 若出现permission denied,请在命令前加sudo。 新建一个网站官网给出以下一套命令进行建站。 1234$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 在当前版本的hexo-cli，npm install不需要执行，在init的时候会安装相应的依赖。 启动服务器1$ hexo server 默认情况下，访问网址为： http://localhost:4000。 Theme默认主题存放于&lt;folder&gt;/themes下，为landscape。你可以从主题列表中挑选自己喜欢的主题，下载并替换。 下载 123$ cd themes/$ git clone https://github.com/probberechts/hexo-theme-cactus.git$ rm -rf landscape/ 修改_config.yml文件: 1theme: hexo-theme-cactus 重新启动服务器进行预览 1$ hexo server","link":"/documents/Technology/Git/github-gitee-pages-hexo.html"},{"title":"Docker Deploy Test","text":"Docker部署Spring Boot应用，以测试Spring Cloud相关组件。 12$ scp -r hanzo@10.122.22.115:/home/hanzo/Workspace/MicroServices/esp-framework .$ scp hanzo@10.122.22.115:/home/hanzo/Workspace/MicroServices/esp-framework/esp-gateway/target/gateway-0.0.1-SNAPSHOT.jar . Runing Mode maven 123$ mvn spring-boot:run \\ -DCFG_CONFIG_HOST=10.122.22.115 \\ -Deureka.client.serviceUrl.defaultZone=http://10.122.22.115:8761/eureka java 123$ java -jar gateway-0.0.1-SNAPSHOT.jar \\ --CFG_CONFIG_HOST=10.122.22.115 \\ --eureka.client.serviceUrl.defaultZone=http://10.122.22.115:8761/eureka docker 1234567891011121314151617181920$ mvn clean package -Dmaven.test.skip=true docker:build$ docker run -d --name esp-registry -p 8761:8761 10.122.22.115:5000/esp-registry$ docker run -d --name esp-config -p 8750:8750 \\ -e CFG_EUREKA_HOST=10.122.22.115 \\ 10.122.22.115:5000/esp-config \\ ; docker logs -f esp-gateway$ docker run -d --name esp-gateway -p 8765:8765 \\ -e CFG_CONFIG_HOST=10.122.22.115 \\ -e SPRING_CLOUD_CONFIG_LABEL=env \\ 10.122.22.115:5000/esp-gateway \\ ; docker logs -f esp-gateway$ docker run -d --name esp-admin -p 8085:8085 \\ -e CFG_CONFIG_HOST=10.122.22.115 \\ -e SPRING_CLOUD_CONFIG_LABEL=env \\ 10.122.22.115:5000/esp-admin \\ ; docker logs -f esp-admin Docker Command Create tag 1234$ docker tag 10.122.22.115:5000/esp-registry 10.122.22.115:5000/esp-registry$ docker tag 10.122.22.115:5000/esp-config 10.122.22.115:5000/esp-config$ docker tag 10.122.22.115:5000/esp-gateway 10.122.22.115:5000/esp-gateway$ docker tag 10.122.22.115:5000/esp-admin10.122.22.115:5000/esp-admin Remove container 1234567$ docker rm -v $(docker stop esp-registry)$ docker rm -v $(docker stop esp-config)$ docker rm -v $(docker stop esp-gateway)$ docker rm -v $(docker stop esp-admin)#! or$ docker ps -a --filter \"name=esp-*\"$ docker rm -v $(docker ps -a --filter \"name=esp-*\" -q) Remove image 12345$ docker images -f \"reference=10.122.22.115:5000/esp-*\"$ docker rmi $(docker images 10.122.22.115:5000/* -q)#! or$ docker rmi -f $(docker images -f \"reference=10.122.22.115:5000/esp-*\" -q) Docker Settings /etc/systemd/system/docker.service.d/http-proxy.conf 123[Service]Environment=&quot;HTTP_PROXY=http://proxy1.bj.petrochina:8080&quot;Environment=&quot;HTTPS_PROXY=http://proxy1.bj.petrochina:8080&quot; &quot;NO_PROXY=localhost, 127.0.0.1, 10.27.213.66, 10.27.213.69, 10.122.22.115&quot; /etc/docker/daemon.json 1234&#123; &quot;registry-mirrors&quot;: [&quot;https://ik8akj45.mirror.aliyuncs.com&quot;], &quot;insecure-registries&quot;: [&quot;10.27.213.66:5000&quot;, &quot;10.122.22.115:5000&quot;]&#125; /var/lib/docker/containers/CONTAINER_ID/hostconfig.json 123456# update port mapping&#123; ... &quot;PortBindings&quot;:&#123;&quot;5000/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;5000&quot;&#125;]&#125; ...&#125; http: server gave HTTP response to HTTPS client 1234567$ vim /etc/docker/daemon.json&#123; \"insecure-registries\":[\"10.122.22.115:5000\"]&#125;$ sudo systemctl daemon-reload$ sudo systemctl restart docker net/http: request canceled (Client.Timeout exceeded while awaiting headers) 12345$ vim /etc/docker/daemon.json&#123; \"registry-mirrors\": [\"https://ik8akj45.mirror.aliyuncs.com\"] # \"registry-mirrors\":[\"https://docker.mirrors.ustc.edu.cn\"]&#125; Questions spring.cloud.client.ip-address[10.27.213.167/172.16.81.167] spring.cloud.client.ip-address[10.27.213.167/172.16.81.167]","link":"/documents/Technology/Docker/docker-deploy-test.html"},{"title":"Nginx Test","text":"Nginx Deploy Test ECS for Aliyun or CVM for Tencent, CentOS 7.2 64Bit Download Download 123456$ cd ~/Downloads$ wget http://nginx.org/download/nginx-1.16.0.tar.gz$ wget https://nodejs.org/dist/v10.16.0/node-v10.16.0-linux-x64.tar.xz$ wget http://mirror.bit.edu.cn/apache/tomcat/tomcat-7/v7.0.94/bin/apache-tomcat-7.0.94.tar.gz$ wget https://dev.tencent.com/u/THRAEX/p/Books/git/raw/master/jdk-8u211-linux-x64.tar.gz Extract 123456$ cd ~/Workspace/Kits$ tar -xzf ~/Downloads/nginx-1.16.0.tar.gz$ tar -xJf ~/Downloads/node-v10.16.0-linux-x64.tar.xz$ tar -xzf ~/Downloads/apache-tomcat-7.0.94.tar.gz$ tar -xzf ~/Downloads/jdk-8u211-linux-x64.tar.gz Rename 1234$ mv apache-tomcat-7.0.94/ tomcat7$ mv nginx-1.16.0/ nginx$ mv node-v10.16.0-linux-x64/ node$ mv jdk1.8.0_211/ jdk1.8 Install JDK/Tomcat7(Environment Variables) 1234567891011121314151617181920212223242526272829$ vim ~/.bash_profile# User specific environment and startup programs#########################PATH=$PATH:$HOME/binKITS_HOME=~/Workspace/Kitsexport JAVA_HOME=$KITS_HOME/jdk1.8export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport CATALINA_BASE=$KITS_HOME/tomcat7export CATALINA_HOME=$KITS_HOME/tomcat7PATH=$PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin:$KITS_HOME/node/binexport PATH#########################$ . ~/.bash_profile$ which java startup.sh node/root/Workspace/Kits/jdk1.8/bin/java/root/Workspace/Kits/tomcat7/bin/startup.sh/root/Workspace/Kits/node/bin/node$ whereis java startup.sh nodejava: /root/Workspace/Kits/jdk1.8/bin/javastartup: /root/Workspace/Kits/tomcat7/bin/startup.bat /root/Workspace/Kits/tomcat7/bin/startup.shnode: /root/Workspace/Kits/node/bin/node$ java -version ; version.sh ; node -v Nginx(make), http://nginx.org/en/docs/configure.html 12$ cd ~/Workspace/Kits/nginx$ ./configure Questions: ./configure: error: the HTTP rewrite module requires the PCRE library. 1$ yum -y install pcre-devel ./configure: error: the HTTP gzip module requires the zlib library. 1$ yum install -y zlib-devel 1234567891011121314151617181920212223$ ./configure...Configuration summary + using system PCRE library + OpenSSL library is not used + using system zlib library nginx path prefix: \"/usr/local/nginx\" nginx binary file: \"/usr/local/nginx/sbin/nginx\" nginx modules path: \"/usr/local/nginx/modules\" nginx configuration prefix: \"/usr/local/nginx/conf\" nginx configuration file: \"/usr/local/nginx/conf/nginx.conf\" nginx pid file: \"/usr/local/nginx/logs/nginx.pid\" nginx error log file: \"/usr/local/nginx/logs/error.log\" nginx http access log file: \"/usr/local/nginx/logs/access.log\" nginx http client request body temporary files: \"client_body_temp\" nginx http proxy temporary files: \"proxy_temp\" nginx http fastcgi temporary files: \"fastcgi_temp\" nginx http uwsgi temporary files: \"uwsgi_temp\" nginx http scgi temporary files: \"scgi_temp\"$ make$ make install Important 安装完成后添加环境变量/usr/local/nginx/sbin/12$ vim ~/.bash_profilePATH=$PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin:$KITS_HOME/node/bin:/usr/local/nginx/sbin/ Git 1$ yum install git Nmap 1$ yum install nmap RunTomcat7 Start startup.sh 1234567$ startup.shUsing CATALINA_BASE: /root/Workspace/Kits/tomcat7Using CATALINA_HOME: /root/Workspace/Kits/tomcat7Using CATALINA_TMPDIR: /root/Workspace/Kits/tomcat7/tempUsing JRE_HOME: /root/Workspace/Kits/jdk1.8Using CLASSPATH: /root/Workspace/Kits/tomcat7/bin/bootstrap.jar:/root/Workspace/Kits/tomcat7/bin/tomcat-juli.jarTomcat started. catalina.sh run(推荐) Note 本地自测: curl http://localhost:8080 公网访问去要配置 安全组规则 点击 添加安全组规则 端口范围：8080/8080 授权对象：0.0.0.0/0 Stop shutdown.sh 123456$ shutdown.shUsing CATALINA_BASE: /root/Workspace/Kits/tomcat7Using CATALINA_HOME: /root/Workspace/Kits/tomcat7Using CATALINA_TMPDIR: /root/Workspace/Kits/tomcat7/tempUsing JRE_HOME: /root/Workspace/Kits/jdk1.8Using CLASSPATH: /root/Workspace/Kits/tomcat7/bin/bootstrap.jar:/root/Workspace/Kits/tomcat7/bin/tomcat-juli.jar catalina.sh stop kill12$ ps -ax | grep tomcat$ kill &lt;PID&gt; Question启动时卡在“ Deploying web application directory ”很久 Whylinux或者部分unix系统提供随机数设备是/dev/random 和/dev/urandom，其中urandom安全性没有random高，但random需要时间间隔生成随机数，jdk默认调用random，从而生成随机数时间间隔长从而到时Tomcat启动速度慢 Solution123456$ vim ~/Workspace/Kits/jdk1.8/jre/lib/security/java.security...# HANZO ADD# securerandom.source=file:/dev/randomsecurerandom.source=file:/dev/./urandom... Nginx需要将/usr/local/nginx/sbin/添加至环境变量 Start: $ nginx Note 本地自测: curl http://localhost 公网访问去要配置 安全组规则 点击 添加安全组规则 端口范围：8080/8080 授权对象：0.0.0.0/0 nginx -s signal stop — fast shutdown quit — graceful shutdown reload — reloading the configuration file reopen — reopening the log files Domain添加 解析记录 记录类型: A 主机记录: @ / www分别对应: http://hanzo.com.cn / http://www.hanzo.com.cn 记录值: 公网IP Note 因备案原因, 主机记录使用www","link":"/documents/Technology/Nginx/nginx-test.html"},{"title":"Spring Cloud Netflix Eureka Client Analysis","text":"Spring Cloud Netflix Eureka Client Analysis 1. Dependencies Version Spring Boot 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; Spring Cloud 1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 依赖顺序 2. Clone Source Code(Optional)2.1 spring-cloud-release12345$ git clone -b vGreenwich.SR2 git@github.com:spring-cloud/spring-cloud-release.git##! or$ git clone -b vGreenwich.SR2 https://github.com/spring-cloud/spring-cloud-release.git$ cd spring-cloud-release ; git checkout -b vGreenwich.SR2 2.2 spring-cloud-netflix12345$ git clone -b v2.1.2.RELEASE git@github.com:spring-cloud/spring-cloud-netflix.git##! or$ git clone -b v2.1.2.RELEASE https://github.com/spring-cloud/spring-cloud-netflix.git$ cd spring-cloud-netflix ; git checkout -b v2.1.2.RELEASE 3. Project Structure spring-cloud-release docs: Spring Cloud Starter Docs spring-cloud-dependencies: 管理依赖(*-dependencies)版本号. spring-cloud-starter-parent: 依赖 spring-cloud-dependencies 目标: org.springframework.cloud:spring-cloud-netflix-dependencies:2.1.2.RELEASE spring-cloud-netflix spring-cloud-netflix-dependencies spring-cloud-netflix-archaius spring-cloud-netflix-core spring-cloud-netflix-concurrency-limits spring-cloud-netflix-hystrix-dashboard spring-cloud-netflix-hystrix-stream spring-cloud-netflix-eureka-client spring-cloud-netflix-eureka-server spring-cloud-netflix-turbine spring-cloud-netflix-turbine-stream spring-cloud-netflix-sidecar spring-cloud-netflix-zuul spring-cloud-netflix-ribbon spring-cloud-starter-netflix spring-cloud-starter-netflix-archaius spring-cloud-starter-netflix-eureka-client spring-cloud-starter-netflix-eureka-server spring-cloud-starter-netflix-hystrix spring-cloud-starter-netflix-hystrix-dashboard spring-cloud-starter-netflix-ribbon spring-cloud-starter-netflix-turbine spring-cloud-starter-netflix-turbine-stream spring-cloud-starter-netflix-zuul spring-cloud-netflix-hystrix docs 3.1 依赖顺序spring-cloud-dependencies –&gt; spring-cloud-netflix-dependencies –&gt; spring-cloud-starter-netflix-eureka-client –&gt; spring-cloud-netflix-eureka-client","link":"/documents/Technology/Spring/Spring-Cloud/spring-cloud-netflix-eureka-client-analysis.html"},{"title":"You Don't Know JS","text":"You Don’t Know JS Study Notes ESJavaScript标准的官方名称是ECMAScript，简称ES。 最早版本ES1和ES2，实现很少，不怎么为人所知。第一个流行起来的版本是ES3，它成为浏览器IE6-8和早前的旧版Android 2.x移动浏览器的JavaScript标准。出于某些政治原因，倒霉的ES4从来没有成形。 2009年，ES5正式发布(然后是2011年的ES5.1)，在当代浏览器(包括Firefox、Chrome、Opera、Safari以及许多其他类型)的进化和爆发中成为JavaScript广泛使用的标准。 ES6，发布日期从2013年拖到2014年，然后又到2015年。 在ES6之前的JavaScript标准通常被称为ES5(严格说是ES5.1)。 1. 作用域作用域是一套规则，用于确定在何处以及如何查找变量(标识符)。 有两种主要工作模型: 词法作用域和动态作用域。 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。是一套关于引擎如何寻找变量及会在何处找到变量的规则。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。 而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从从何处调用。 两者之间主要区别: 词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。 词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。 编译执行1var a = 2; 编译阶段 遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译;否则它会要求作用域在当前作 用域的集合中声明一个新的变量，并命名为a。 执行阶段 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a = 2这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作a的 变量。如果是，引擎就会使用这个变量;如果否，引擎会继续查找该变量。 12'use strict'; // ES5引入a = 2; 上述代码对于a = 2，如果引擎最终在所有可访问的词法作用域中找到了a变量，就会将2赋值给它。否则引擎就会抛出一个异常。 12345function foo(a) &#123; console.log(a, b); // ReferenceError: b is not defined&#125;foo(2); 当获取某个变量的值，在所有嵌套作用域中找不到所需变量，引擎就会抛出ReferenceError，即作用域判别失败。而TypeError则是作用域判别成功了，但是对结果的操作是非法或不合理的。 常见作用域单元 函数声明 123456789var a = 4;function foo() &#123; var a = 3; console.log(a); // 3&#125;foo();console.log(a); // 4 匿名函数表达式 12345678var a = 4;setTimeout(function() &#123; var a = 3; console.log(a); // 3&#125;, 1000);console.log(a); // 4 具名函数表达式 123setTimeout(function hadnler() &#123; // ...&#125;, 1000); 立即执行函数表达式 12345678var a = 4;(function() &#123; var a = 3; console.log(a); // 3&#125;)();console.log(a); // 4 社区规定术语：IIFE(Immediately Invoked Function Expression)。最佳实践：123(function IIFE() &#123; // ...&#125;)(); 块12345for (var i = 0; i &lt; 10; i++) &#123; console.log(i);&#125;console.log(i); // 10 1234567var t = true;if (t) &#123; var a = 3; console.log(a);&#125;console.log(a); // 3 变量的声明应该距离使用的地方越近越好。但是，上述代码中变量i和a，会被绑定在外部作用域(函数或全局)(提升)，它们只是为了风格而伪装出的形式上的块作用域。为了防止在作用域内被提升，ES6引入了let关键字。 提升123a = 2;var a;console.log(a); 12console.log(a);var a = 2; 变量和函数的所有声明都会在任何代码被执行前首先被处理。就好像它们在代码中出现的位置被“移动”到了最上面，这个过程就叫提升。 So，以上两段代码会以如下形式进行处理：123var a;a = 2;console.log(a); 123var a;console.log(a);a = 2; 只有声明本身会被提升，赋值或其他运行逻辑会留在原地，等待被执行。如果提改变了代码的执行顺序，会造成非常严重的破坏 每个作用域都会进行提升操作 函数会优先被提升 2. 闭包识别闭包当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 12345678910111213function foo() &#123; var a = 2; function bar() &#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); // 2 —— 闭包的效果 在foo()执行后，通常会期待foo()的整个内部作用域都被销毁，因为引擎有垃回收器用来释放不再使用的内存空间。由于看上去foo()的内容不会再被使用，所以很自然地会考虑对其进行回收。 闭包的存在使得foo()内部作用域没有被回收。bar()本身在使用内部作用域，它依然持有对该作用域的引用，这个引用就叫“闭包”。 无论使用哪种形式对函数类型的值进行传递，当函数在别处被调用时，就会产生闭包。 12345678910111213function foo() &#123; var a = 2; function baz() &#123; console.log(a); // 2 &#125; bar(baz);&#125;function bar(fn) &#123; fn(); // 闭包&#125; 12345678910111213141516171819var fn;function foo() &#123; var a = 2; function baz() &#123; console.log(a); &#125; fn = baz; // 将baz分配给全局变量，间接传递&#125;function bar() &#123; fn(); // 闭包&#125;foo();bar(); // 2 123456789function wait(msg) &#123; var type = 'info:'; setTimeout(function timer() &#123; console.log(type, msg); // info: hello, closure &#125;, 1000);&#125;wait('hello, closure'); 循环和闭包 共享全局作用域12345for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; // timer会在循环结束时才执行 console.log(i); &#125;, i*1000);&#125; 理想情况是循环中的每个迭代在运行时都会给自己“捕获”一个i的副本。但是根据作用域的工作原理，尽管五个函数是在各个迭代中分别定义的，但其实它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i。 每个迭代创建一个闭包作用域 1234567891011121314151617for (var i = 1; i &lt;= 5; i++) &#123; (function() &#123; var j = i; setTimeout(function timer() &#123; console.log(j); &#125;, j*1000); &#125;)();&#125;// 改进版for (var i = 1; i &lt;= 5; i++) &#123; (function(j) &#123; setTimeout(function timer() &#123; console.log(j); &#125;, j*1000); &#125;)(i);&#125; 使用块作用域 12345for (let i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i*1000);&#125; 模块12345678910111213141516171819202122function CoolModule() &#123; var something = \"cool\"; var another = [1, 2, 3]; function doSomething() &#123; console.log(something); &#125; function doAnother() &#123; console.log(another.join(\" ! \")); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;;&#125;var foo = CoolModule();foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3 以上模式在JavaScript中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露，这里展示的是其变体。 模块模式需要具备两个必要条件： 必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 上一段代码中有一个叫作CoolModule()的独立的模块创建器，可以被调用任意多次，每次调用都会创建一个新的模块实例。当只需要一个实例时，可以对这个模式进行简单的改进来实现单例模式:1234567891011121314151617181920var foo = (function CoolModule() &#123; var something = \"cool\"; var another = [1, 2, 3]; function doSomething() &#123; console.log(something); &#125; function doAnother() &#123; console.log(another.join(\" ! \")); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;;&#125;)();foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3 现代模块机制模块加载器/管理器：12345678910111213141516171819var MyModules = (function Manager() &#123; var modules = &#123;&#125;; function define(name, deps, impl) &#123; for (var i = 0; i &lt; deps.length; i++) &#123; deps[i] = modules[deps[i]]; &#125; modules[name] = impl.apply(impl, deps); // 核心 &#125; function get(name) &#123; return modules[name]; &#125; return &#123; define: define, get: get &#125;;&#125;)(); 定义模块：1234567891011121314151617181920212223242526272829MyModules.define( \"bar\", [], function() &#123; function hello(who) &#123; return \"Let me introduce: \" + who; &#125; return &#123; hello: hello &#125;;&#125;);MyModules.define( \"foo\", [\"bar\"], function(bar) &#123; var hungry = \"hippo\"; function awesome() &#123; console.log(bar.hello( hungry ).toUpperCase()); &#125; return &#123; awesome: awesome &#125;;&#125;);var bar = MyModules.get( \"bar\" );var foo = MyModules.get( \"foo\" );console.log(bar.hello( \"hippo\" )); // Let me introduce: hippofoo.awesome(); // LET ME INTRODUCE: HIPPO 未来模块机制 bar.js 12345function hello(who) &#123; return \"Let me introduce: \" + who;&#125;export hello; foo.js 12345678910// 仅从 \"bar\" 模块导入 hello()import hello from \"bar\";var hungry = \"hippo\";function awesome() &#123; console.log(hello(hungry).toUpperCase());&#125;export awesome; baz.js 123456module foo from \"foo\";module bar from \"bar\";console.log(bar.hello(\"rhino\")); // Let me introduce: rhinofoo.awesome(); // LET ME INTRODUCE: HIPPO 3. thisthis可以优雅的隐式“传递”一个对象引用，让API设计的更加简洁并且易于使用。如果显示传递上下文对象会让代码变的越来越混乱。 this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this就是记录的 其中一个属性，会在函数执行的过程中用到。 误解指向函数自身记录函数foo的被调用次数：1234567891011121314151617function foo(num) &#123; console.log(\"foo: \" + num); // 记录 foo 被调用的次数 this.count++;&#125;foo.count = 0;var i;for (i = 0; i &lt; 10; i++) &#123; if (i &gt; 5) &#123; foo(i); &#125;&#125;console.log(foo.count); // 0console.log(count); // NaN 12345678910111213141516171819function foo(num) &#123; console.log(\"foo: \" + num); // 记录 foo 被调用的次数 this.count++;&#125;foo.count = 0;var i;for (i = 0; i &lt; 10; i++) &#123; if (i &gt; 5) &#123; // 使用 call(..) 可以确保 this 指向函数对象 foo 本身 foo.call(foo, i); &#125;&#125;console.log(foo.count); // 4 指向函数的作用域在某种情况下是正确的，但是在其他情况下却是错误的。 this在任何情况下都不指向函数的词法作用域。 12345678910function foo() &#123; var a = 2; this.bar();&#125;function bar() &#123; console.log(this.a);&#125;foo(); 调用位置调用位置，即函数被调用的位置，可以分析调用栈得到。真正的的调用位置，决定了this绑定。 123456789101112131415161718192021222324function baz() &#123; // 当前调用栈是:baz // 因此，当前调用位置是全局作用域 console.log( \"baz\" ); bar(); // &lt;-- bar 的调用位置&#125;function bar() &#123; // 当前调用栈是 baz -&gt; bar // 因此，当前调用位置在 baz 中 console.log( \"bar\" ); foo(); // &lt;-- foo 的调用位置&#125;function foo() &#123; // 当前调用栈是 baz -&gt; bar -&gt; foo // 因此，当前调用位置在 bar 中 console.log( \"foo\" );&#125;baz(); // &lt;-- baz 的调用位置 Chrome: anonymous Firefox: global 绑定规则默认绑定最常用的函数调用类型：独立函数调用。 1234567function foo() &#123; console.log(this.a); // this指向全局对象。&#125;var a = 2;foo(); // 2 12345678function foo() &#123; \"use strict\"; console.log(this); // this绑定到undefined&#125;var a = 2;foo(); // TypeError: Cannot read property 'a' of undefined 12345678910function foo() &#123; console.log(this.a); // this指向全局对象。&#125;var a = 2;(function() &#123; \"use strict\"; foo(); // 2&#125;)(); 通常不会在代码中混合使用strict模式和非strict模式。 隐式绑定在一个对象内部包含一个指向函数的属性，通过这个属性间接引用函数，从而把this隐式绑定到这个对象上。 当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。 12345678910function foo() &#123; console.log(this.a); // this被绑定到obj&#125;var obj = &#123; a: 2, foo: foo&#125;;obj.foo(); // 2 对象属性引用链中只有上一层(最后一层)在调用位置中起作用。e.g.:123456789101112131415function foo() &#123; console.log(this.a);&#125;var obj2 = &#123; a: 42, foo: foo&#125;;var obj1 = &#123; a: 2, obj2: obj2&#125;;obj1.obj2.foo(); //42 隐式丢失 丢失绑定对象，应用默认绑定，从而绑定到全局对象或undefined。 函数引用传递 1234567891011121314function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;var bar = obj.foo; // 函数别名var a = \"oops, global\";bar(); // oops, global 传入回调 123456789101112131415161718function foo() &#123; console.log(this.a);&#125;function doFoo(fn) &#123; // fn引用的是foo fn(); // &lt;-- 调用位置&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = \"oops, global\";doFoo(obj.foo); // oops, global 显式绑定在某个对象上强制调用函数，可以使用call(..)和apply(..)。 123456789function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2&#125;;foo.call(obj); // 2 如果传入一个原始值(字符串类型/布尔类型/数字类型)来当作this的绑定对象，这个原始值会被转换成相应的对象形式(new String()/new Boolean()/new Number())。即装箱。 显式绑定仍然会出现丢失绑定的问题。 1234567891011121314function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;var bar = obj.foo;var a = \"oops, global\";bar(); // oops, global 使用显式绑定的一个变种可以解决这个问题，称为硬绑定。 123456789101112131415function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2&#125;;var bar = function() &#123; foo.call(obj);&#125;bar(); // 2bar.call(window); // 2 由于硬绑定是一种非常常用的模式，所以在ES5中提供了内置的方法Function.prototype.bind，它的用法如下: 12345678910111213function foo(something) &#123; console.log(this.a, something); return this.a + something;&#125;var obj = &#123; a:2&#125;;var bar = foo.bind(obj);var b = bar(3); // 2 3console.log(b); // 5 bind(..)会返回一个硬编码的新函数，它会把你指定的参数设置为this的上下文并调用原始函数。 new绑定在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用new初始化类时会被调用。通常形式如下： 1User user = new User(); 在JavaScript中，new的机制和面向类的语言完全不同。构造函数只是一些使用new操作符时被调用的普通函数。它们并不会属于某个类，也不会实例化一个类。 使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 1.创建(或者说构造)一个全新的对象。 2.这个新对象会被执行[[Prototype]]连接。 3.这个新对象会绑定到函数调用的this。 4.如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 123456function foo(a) &#123; this.a = a;&#125;var bar = new foo(2);console.log(bar.a); // 2 优先级关于this的四条绑定规则，只需要找到函数的调用位置，基本就可以判断该应用哪条规则。但是，有些调用位置可以应用多条规则，这时就必须根据优先级来进行判断了。 毫无疑问，默认绑定的优先级是最低的。 显式绑定 vs 隐式绑定12345678910111213141516171819function foo() &#123; console.log(this.a);&#125;var obj1 = &#123; a: 2, foo: foo&#125;;var obj2 = &#123; a: 3, foo: foo&#125;;obj1.foo(); // 2obj2.foo(); // 3obj1.foo.call(obj2); // 3obj2.foo.call(obj1); // 2 显式绑定优先级高于隐式绑定。 new绑定 vs 隐式绑定12345678910111213141516171819function foo(something) &#123; this.a = something;&#125;var obj1 = &#123; foo: foo&#125;;var obj2 = &#123;&#125;;obj1.foo(2);console.log(obj1.a); // 2obj1.foo.call(obj2, 3);console.log(obj2.a); // 3var bar = new obj1.foo(4);console.log(obj1.a); // 2console.log(bar.a); // 4 new绑定优先级高于隐式绑定。 new绑定 vs 显式绑定12345678910111213function foo(something) &#123; this.a = something;&#125;var obj1 = &#123;&#125;;var bar = foo.bind(obj1);bar(2);console.log(obj1.a); // 2var baz = new bar(3);console.log(obj1.a); // 2console.log(baz.a); // 3 bar被硬绑定到obj1上，但是new bar(3)并没有把obj1.a修改为3。相反，new修改了硬绑定调用bar(..)中的this。使用new绑定，得到一个名为baz的新对象，并且baz.a的值是3。 判断this 1.函数是否在new中调用(new绑定)？如果是的话this绑定的是新创建的对象。 1var bar = new foo(); 2.函数是否通过call、apply(显式绑定)或者硬绑定调用？如果是的话，this绑定的是指定的对象。 1var bar = foo.call(obj2); 3.函数是否在某个上下文对象中调用(隐式绑定)？如果是的话，this绑定的是那个上下文对象。 1var bar = obj1.foo(); 4.如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。 1var bar = foo(); 4. 原型5. 异步 回调是JavaScript中最基础的异步模式。 以下代码被称为回调地狱(callback hell)，有时也被称为毁灭金字塔(pyramid of doom)：1234567891011listen(\"click\", function handler(evt) &#123; setTimeout(function request() &#123; ajax(\"http://some.url.1\", function response(text) &#123; if (text == \"hello\") &#123; handler(); &#125; else if (text == \"world\") &#123; request(); &#125; &#125;); &#125;, 500) ;&#125;); 为了更优雅的处理错误，有些API设计提供了分离回调：123456789function success(data) &#123; console.log(data);&#125;function failure(err) &#123; console.error(err);&#125;ajax(\"http://some.url.1\", success, failure); ES6特性语法特性1. 块作用域letlet可以将变量绑定到所在的任意作用域中(通常是{..}内部)。换句话说，let为其声明的变量隐式的劫持了所在的块作用域。 12345for (let i = 0; i &lt; 10; i++) &#123; console.log(i);&#125;console.log(i); // ReferenceError: i is not defined 1234567891011121314var t = true;if (t) &#123; let a = 3; console.log(a);&#125;console.log(a); // ReferenceError: a is not definedif (t) &#123; &#123; // 显式的块 let b = 2; console.log(b); &#125;&#125; 12345678var a = 2;&#123; let a = 3; console.log(a); // 3&#125;console.log(a); // 2 let声明不会在块作用域中进行提升:1234567&#123; console.log(a); // undefined console.log(b); // ReferenceError: c is not defined var a; let b;&#125; 垃圾收集: 12345678910111213function process(data) &#123; // ...&#125;var someReallyBigData = &#123; .. &#125;;process(someReallyBigData);var btn = document.getElementById( \"my_button\" );btn.addEventListener( \"click\", function click(evt) &#123; console.log(\"button clicked\");&#125;, /*capturingPhase=*/false ); click函数的点击回调并不需要someReallyBigData变量。理论上这意味着当process(..)执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于click函数形成了一个覆盖整个作用域的闭包，JavaScript引擎极有可能依然保存着这个结构(取决于具体实现)。 块作用域可以打消这种顾虑，可以让引擎清楚地知道没有必要继续保存someReallyBigData了:123456789101112131415function process(data) &#123; // ...&#125;// 在这个块中定义的内容可以销毁了!&#123; let someReallyBigData = &#123; .. &#125;; process( someReallyBigData );&#125;var btn = document.getElementById( \"my_button\" );btn.addEventListener( \"click\", function click(evt)&#123; console.log(\"button clicked\");&#125;, /*capturingPhase=*/false ); 注意: 尽量把let声明放在块的最前面 声明多个变量，建议使用一个let1let a, b, c; const123const a = 2;console.log(a);a = 3; //TypeError 用于创建常量 常量不是对这个值本身的限制，而是对赋值的那个变量的限制 大写字母+下划线1const MAX_VALUE = 10; 块作用域函数ES6之前condition无论值为什么，bar声明都会被提升，最后一个胜出。 1234567891011if (condition) &#123; function bar() &#123; console.log(1); &#125;&#125; else &#123; function bar() &#123; console.log(2); &#125;&#125;bar(); 2. spread/rest新运算符... 12345678910111213141516171819202122// spread: 把变量展开为各个独立的值function foo(x, y, z) &#123; console.log(x, y, z);&#125;foo(...[1, 2, 3]);// [1].concat(a, [5])var a = [2, 3, 4];var b = [1, ...a, 5];console.log(b);// rest: 把一系列值收集到一起成为一个数组function foo(x, y, ...z) &#123; console.log(x, y, z);&#125;foo(1, 2, 3, 4, 5);function foo(...r) &#123; console.log(r);&#125;foo(1, 2, 3, 4, 5); arguments，并不是真正的数组，而是类似数组的对象。已被弃用，不推荐使用。 1234567891011121314151617181920212223242526272829// 按照新的ES6的行为方式实现function foo(...args) &#123; // args已经是一个真正的数组 // 丢弃args中第一个元素 args.shift(); // 把整个args作为参数传给console.log(..) console.log( ...args );&#125;// 按照前ES6的老派行为方式实现function bar() &#123; // 把arguments转换为一个真正的数组 var args = Array.prototype.slice.call( arguments ); // 在尾端添加几个元素 args.push( 4, 5 ); // 过滤掉奇数 args = args.filter( function(v)&#123; return v % 2 == 0; &#125; ); // 把整个args作为参数传给foo(..) foo.apply( null, args );&#125;bar( 0, 1, 2, 3 ); // 2 4 3. 默认参数值简单默认值ES5中默认值的实现，作用很大，也很危险。 1234567891011121314function foo(x, y) &#123; x = x || 11; y = y || 31; // x = (x !== undefined) ? x : 11; // y = (y !== undefined) ? y : 31; console.log(x + y);&#125;foo();foo(5, 6);foo(5);foo(null, 6); 被认为是假的值 1foo(0, 42) 省略第一个参数 12345678910foo(, 6);foo.apply(null, [, 6]);function foo(obj) &#123; obj = obj || &#123;&#125;; obj.a = obj.a || 11; // ..&#125; ES6缺失参数赋值123456789101112function foo(x = 11, y = 31) &#123; console.log( x + y );&#125;foo();foo( 5, 6 );foo( 0, 42 );foo( 5 );foo( 5, undefined );foo( 5, null );foo( undefined, 6 );foo( null, 6 ); 表达式默认值函数默认值除了是简单值，可以是任意合法表达式，甚至是函数调用。 123456789101112131415161718function bar(val) &#123; console.log( \"bar called!\" ); return y + val;&#125;function foo(x = y + 3, z = bar( x )) &#123; console.log(x, z);&#125;var y = 5;foo(); // bar called! // 8 13foo( 10 ); // bar called! // 10 15y = 6;foo( undefined, 10 ); // 9 10 默认值表达式中的标识符引用首先匹配到形式参数作用域&#39;(...)&#39;，然后才会搜索外层作用域。 1234567// z已经声明，但未初始化var w = 1, z = 2;function foo(x = w + 1, y = x + 1, z = z + 1) &#123; console.log(x, y, z);&#125;foo(); // ReferenceError 默认回调函数 12345function dialog(msg, cb = function() &#123;&#125;) &#123; // ..&#125;dialog('Hello'); 4. 对象字面量扩展简洁属性12var x = 2, y = 3;var o = &#123; x: x, y: y &#125;; 对象属性名与词法标识符(变量)同名，则可如下简写: 12var x = 2, y = 3;var o = &#123; x, y &#125;; 简洁方法1234var o = &#123; x: function() &#123;&#125;, y: function() &#123;&#125;&#125;; 1234var o = &#123; x() &#123;&#125;, y() &#123;&#125;&#125;; 计算属性名123456789var prefix = \"user_\";var o = &#123; baz: function(..) &#123; .. &#125;&#125;;o[prefix + \"foo\"] = function(..) &#123; .. &#125;;o[prefix + \"bar\"] = function(..) &#123; .. &#125;;o[prefix + \"id\"] = \"9527\"; 12345678var prefix = \"user_\";var o = &#123; baz: function(..) &#123; .. &#125;, [prefix + \"foo\"]: function(..) &#123; .. &#125;, [prefix + \"bar\"]: function(..) &#123; .. &#125;, [prefix + \"id\"]: \"9527\"&#125;; 此外还有[[Prototype]]的设定，super对象。 5. 解构解构(destructuring)可以看作是一个结构化赋值(structured assignment)方法。 曾经的手动赋值：1234567891011121314151617181920212223// 数组function foo() &#123; return [1, 2, 3];&#125;// 对象function bar() &#123; return &#123; x: 4, y: 5, z: 6 &#125;;&#125;var tmp = foo(), // 临时变量 a = tmp[0], b = tmp[1], c = tmp[2];console.log(a, b, c); // 1 2 3var obj = bar(), // 临时变量 x = obj.x, y = obj.y, z = obj.z;console.log(x, y, z); // 4 5 6 ES6新增了一个专门语法，专用于数组解构和对象解构。这个语法消除了前面代码对临时变量的需求，使代码更加简洁。 1234567// 数组解构var [a, b, c] = foo();console.log(a, b, c); // 1 2 3// 对象解构var &#123; x: x, y: y, z: z &#125; = bar();console.log(x, y, z); // 4 5 6 对象属性赋值模式如果属性名和要赋值的变量名相同，可以使用简洁属性使得语法更加简短。 1234var &#123; x: x, y: y, z: z &#125; = bar();// 简洁属性var &#123; x, y, z &#125; = bar(); 对于{ x, .. }，缩写语法省略了x:部分。 简短的形式使得代码更简洁，但是更长的的形式支持把属性赋给非同名变量：1234var &#123; x: bam, y: baz, z: bap &#125; = bar();console.log(bam, baz, bap); // 4 5 6console.log(x, y, z); // ReferenceError 语法模式比较: 对象字面值：target: source(target &lt;-- source) 对象解构赋值：source: target(source --&gt; target) 123456var aa = 10, bb = 20;var o = &#123; x: aa, y: bb &#125;;var &#123; x: AA, y: BB &#125; = o;console.log(AA, BB); // 10 20 不只是声明解构是一个通用的赋值操作，不仅仅是声明。 1234567var a, b, c, x, y, z;[a, b, c] = foo();( &#123; x, y, z &#125; = bar() ); // 省略了声明符，必须把整个赋值表达式用(..)括起来console.log(a, b, c); // 1 2 3console.log(x, y, z); // 4 5 6 任何合法的赋值表达式都可以用解构赋值。 123456var o = &#123;&#125;;[o.a, o.b, o.c] = foo();( &#123; x: o.x, y: o.y, z: o.z &#125; = bar() );console.info(o); 使用计算属性：123456var which = 'x', o = &#123;&#125;;( &#123; [which]: o[which] &#125; = bar() );console.log(o); 不用临时变量交换两个变量：12345var x = 10, y = 20;[y, x] = [x, y];console.log(x, y); // 20 10 重复赋值123var &#123; a: X, a: Y &#125; = &#123; a: 1 &#125;;console.log(X, Y); // 1 1 解构子对象/数组属性： 12345678910111213var &#123; a: &#123; x: X, x: Y &#125;, a &#125; = &#123; a: &#123; x: 1 &#125; &#125;;console.log(X, Y);console.log(a);( &#123; a: X, a: Y, a: [Z] &#125; = &#123; a: [1] &#125; );X.push(2);Y[0] = 10;console.log(X); // [10, 2]console.log(Y); // [10, 2]console.log(Z); // 1 6. 模板字面量模板字面量更应该被称为插入字符串字面量。 ES6之前的字符串连接方式：123456var name = \"Kyle\";var greeting = \"Hello \" + name + \"!\";console.log(greeting); // Hello Kyle!console.log(typeof greeting); // string ES6中的方式：123456var name = \"Kyle\";var greeting = `Hello $&#123;name&#125;!`;console.log(greeting); // Hello Kyle!console.log(typeof greeting); // string 插入字符串字面量的一个优点是它们可以分散在多行:123456var text = `Now is the time for all good men to come to the aid of their country!`;console.log( text ); 插入表达式在插入字符串字面量的${..}内可以出现任何合法的表达式，包括函数调用、在线函数表达式调用，甚至其他插入字符串字面量! 12345678910function upper(s) &#123; return s.toUpperCase();&#125;var who = \"reader\";var text = `A very $&#123;upper( \"warm\" )&#125; welcome to all of you $&#123;upper( `$&#123;who&#125;s` )&#125;!`;console.log( text ); 标签模板字面量123456789function foo(strings, ...values) &#123; console.log( strings ); console.log( values );&#125;var desc = \"awesome\";foo`Everything is $&#123;desc&#125;!`; // [\"Everything is \", \"!\"] // [\"awesome\"] 7. 箭头函数普通函数和箭头函数对比：1234567function foo(x, y) &#123; return x + y;&#125;// 对比var foo = (x, y) =&gt; x + y; 不同形式的箭头函数：12345678var f1 = () =&gt; 12;var f2 = x =&gt; x * 2;var f3 = (x, y) =&gt; &#123; var z = x * 2 + y; y++; x *= 3; return (x + y + z) / 2;&#125;; 箭头函数特点： 标识=&gt;前面是参数，后面是函数体 零个或多个参数，需要用( .. )括起来 函数体的表达式多余1个，或者函数体包含非表达式语句的时候需要用{ .. }括起来 如果只有一个表达式，并且省略了{ .. }，则意味着表达式前面有一个隐含的return 箭头函数不仅仅是更短的语法，而是this。在箭头函数内部，this绑定不是动态的，而是词法的。 123456789101112131415161718function foo() &#123; // 返回一个箭头函数 return (a) =&gt; &#123; // this继承自foo() console.log(this.a); &#125;;&#125;var obj1 = &#123; a: 2&#125;;var obj2 = &#123; a: 3&#125;;var bar = foo.call(obj1);bar.call(obj2); // 2， 不是3 箭头函数最常用于回调函数中，例如事件处理器或定时器：1234567891011function foo() &#123; setTimeout(() =&gt; &#123; console.log(this.a); &#125;);&#125;var obj = &#123; a: 2&#125;;foo.call(obj); // 2 曾经使用的一种几乎和箭头函数完全一样的模式：12345678910111213function foo() &#123; var self = this; setTimeout(function() &#123; console.log(self.a); &#125;);&#125;var obj = &#123; a: 2&#125;;foo.call(obj); // 2 8. for..of循环在for和for..in循环组合起来的基础上，ES6又新增了一个for..of循环，在迭代器产生的一系列值上循环。 for..of循环的值必须是一个iterable，或者可以转换/封箱到一个iterable对象的值。 1234567891011121314151617181920var a = [\"a\", \"b\", \"c\", \"d\", \"e\"];for (var idx in a) &#123; console.log(idx); // 0 1 2 3 4&#125;for (var val of a) &#123; console.log(val); // a b c d e&#125;var b = &#123; x: 1, y: 2, z: 3 &#125;;for (var idx in b) &#123; console.log(idx);&#125;// TypeError: b is not iterablefor (var val of b) &#123; console.log(val);&#125; JavaScript中默认为iterable的标准内建值包括： Arrays Strings Generators Collections / TypedArrays 在原生字符串的字符上迭代： 123for (var c of \"hello\") &#123; console.log(c); // h e l l o&#125; 原生字符串值”hello”被强制类型转换/封箱到邓建的String封装对象中。 9. 正则表达式10. 数字字面量11. Unicode12. Symbol代码组织1. 迭代器2. 生成器3. 模块4. 类异步流控制1. Promise1234567891011function ajax(url, cb) &#123; // 建立请求，最终调用cb&#125;ajax(\"http://some.url.1\", function handler(err, contents) &#123; if (err) &#123; // 处理错误 &#125; else &#123; // 处理contents &#125;&#125;); 1234567891011121314function ajax(url) &#123; return new Promise(function pr(resolve, reject) &#123; // 建立请求，最终调用resolve(..)或reject(..) &#125;);&#125;ajax(\"http://some.url.1\").then( function fulfilled(contents) &#123; // 处理contents &#125;, function rejected(reason) &#123; // 处理错误原因 &#125;); 2. 生成器 + Promise","link":"/documents/Technology/JavaScript/you-don-t-know-js.html"}],"tags":[{"name":"Git Pages","slug":"Git-Pages","link":"/tags/Git-Pages/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"spring-cloud","slug":"spring-cloud","link":"/tags/spring-cloud/"},{"name":"netflix","slug":"netflix","link":"/tags/netflix/"},{"name":"eureka","slug":"eureka","link":"/tags/eureka/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"}],"categories":[{"name":"Technology","slug":"Technology","link":"/categories/Technology/"},{"name":"Git","slug":"Technology/Git","link":"/categories/Technology/Git/"},{"name":"Docker","slug":"Technology/Docker","link":"/categories/Technology/Docker/"},{"name":"Nginx","slug":"Technology/Nginx","link":"/categories/Technology/Nginx/"},{"name":"Spring","slug":"Technology/Spring","link":"/categories/Technology/Spring/"},{"name":"Spring-Cloud","slug":"Technology/Spring/Spring-Cloud","link":"/categories/Technology/Spring/Spring-Cloud/"},{"name":"JavaScript","slug":"Technology/JavaScript","link":"/categories/Technology/JavaScript/"}]}